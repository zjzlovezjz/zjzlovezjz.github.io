<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="分享之上">
<meta property="og:type" content="website">
<meta property="og:title" content="分享至上">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="分享至上">
<meta property="og:description" content="分享之上">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分享至上">
<meta name="twitter:description" content="分享之上">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>分享至上</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">分享至上</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我爱学习</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/java8新特性之四大内置核心函数式接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/java8新特性之四大内置核心函数式接口/" itemprop="url">java8新特性之四大内置核心函数式接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T20:37:32+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java8新特性/" itemprop="url" rel="index">
                    <span itemprop="name">java8新特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>四大内置核心函数式接口<br>因为每次使用Lambda表达式都要函数式接口的支持，但其实大部分情况不需要自己去创建，因为java8有四大内置函数式接口提供支持，只有一些特殊的情况才需要自己去创建函数式接口<br> Java8 内置的四大核心函数式接口</p>
<ul>
<li></li>
<li>Consumer<t> : 消费型接口</t></li>
<li>void accept(T t);</li>
<li></li>
<li>Supplier<t> : 供给型接口</t></li>
<li>T get(); </li>
<li></li>
<li>Function&lt;T, R&gt; : 函数型接口</li>
<li>R apply(T t);</li>
<li></li>
<li>Predicate<t> : 断言型接口</t></li>
<li><p>boolean test(T t);<br>下面对上述四种内置函数式接口举例说明，第一个，消费型接口，有去无回的类型<br>public void happy(double money, Consumer<double> con){<br>con.accept(money);<br>}<br>//Consumer<t> 消费型接口 :有去无回<br>@Test<br>public void test1(){<br>happy(10000, (m) -&gt; System.out.println(“你们州哥喜欢大宝剑，每次消费：” + m + “元”));<br>} </t></double></p>
</li>
<li><p>Supplier<t> : 供给型接口</t></p>
</li>
<li>T get(); </li>
<li><p>//需求举例：产生指定个数的整数，并放入集合中<br> public List<integer> getNumList(int num, Supplier<integer> sup){</integer></integer></p>
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

for (int i = 0; i &lt; num; i++) {
    Integer n = sup.get();
    list.add(n);
}

return list;
</code></pre><p> }<br> @Test<br> public void test2(){</p>
<pre><code>List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100));

for (Integer num : numList) {
    System.out.println(num);
}
</code></pre><p> }<br>Function&lt;T, R&gt; : 函数型接口</p>
</li>
<li><p>R apply(T t);<br>//需求举例：用于处理字符串<br>public String strHandler(String str, Function&lt;String, String&gt; fun){<br>return fun.apply(str);<br>}<br>@Test<br>public void test3(){<br>String newStr = strHandler(“\t\t\t 我大尚硅谷威武   “, (str) -&gt; str.trim());<br>System.out.println(newStr);</p>
<p>String subStr = strHandler(“我大尚硅谷威武”, (str) -&gt; str.substring(2, 5));<br>System.out.println(subStr);<br>}<br>Predicate<t> : 断言型接口</t></p>
</li>
<li><p>boolean test(T t);<br>//需求举例子：将满足条件的字符串，放入集合中<br>public List<string> filterStr(List<string> list, Predicate<string> pre){<br>List<string> strList = new ArrayList&lt;&gt;();</string></string></string></string></p>
<p>for (String str : list) {<br> if(pre.test(str)){</p>
<pre><code>strList.add(str);
</code></pre><p> }<br>}</p>
<p>return strList;<br>}<br>@Test<br>public void test4(){<br>List<string> list = Arrays.asList(“Hello”, “atguigu”, “Lambda”, “www”, “ok”);<br>List<string> strList = filterStr(list, (s) -&gt; s.length() &gt; 3);</string></string></p>
<p>for (String str : strList) {<br> System.out.println(str);<br>}<br>}</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/java8新特性之Lambda表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/java8新特性之Lambda表达式/" itemprop="url">java8新特性之Lambda表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T11:27:21+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java8新特性/" itemprop="url" rel="index">
                    <span itemprop="name">java8新特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java8新特性简介<br>1.速度更快<br>2.代码更少（增加了新的语法Lambda表达式）<br>3.拥有强大的Stream API<br>4.便于并行<br>5.最大化减少空指针异常Optional<br>其中最为核心的就是Lambda表达式与Stream API</p>
<p>1-Lambda表达式<br><img src="/2018/03/26/java8新特性之Lambda表达式/clipboard.png" alt="enter description here" title="clipboard.png"><br>一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符</p>
<ul>
<li>箭头操作符将 Lambda 表达式拆分成两部分：</li>
<li>左侧：Lambda 表达式的参数列表</li>
<li>右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体</li>
<li>语法格式一：无参数，无返回值</li>
<li><p>() -&gt; System.out.println(“Hello Lambda!”);<br>举例子：找一个无参数无返回值的接口函数<br>@Test<br> public void test1(){</p>
<pre><code> Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;Hello World!&quot;);
    }
};
r.run();

System.out.println(&quot;---------------------&quot;);

Runnable r1 = () -&gt; System.out.println(&quot;Hello Lambda!&quot;);    
r1.run();
</code></pre><p> }<br>语法格式二：有一个参数，并且无返回值</p>
</li>
<li>(x) -&gt; System.out.println(x)<br>举例子：找一个有参数无返回值的接口<br>@Test<br>public void test2(){<br>Consumer<string> con = (x) -&gt; System.out.println(x);<br>con.accept(“州哥威武！！”);<br>}<br>这个例子中的Lambda表达式就是对Consumer接口的accept()方法的实现</string></li>
</ul>
<p>语法格式三：若只有一个参数，小括号可以省略不写</p>
<ul>
<li>x -&gt; System.out.println(x)<br>接着上面的例子<br>@Test<br>public void test2(){<br>Consumer<string> con = x -&gt; System.out.println(x);<br>con.accept(“州哥威武！！”);<br>}<br>语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句，必须使用大括号<br>@Test<br>public void test3(){<br>Comparator<integer> com = (x,y) -&gt; {<br>   System.out.println(“函数式接口”);<br>   return Integer.compare(x, y);<br>};<br>}<br>语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写</integer></string></li>
<li>Comparator<integer> com = (x, y) -&gt; Integer.compare(x, y);<br>语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</integer></li>
<li>(Integer x, Integer y) -&gt; Integer.compare(x, y);<br>上联：左右遇一括号省</li>
<li>下联：左侧推断类型省</li>
<li>横批：能省则省<br>二、Lambda 表达式需要“函数式接口”的支持</li>
<li>函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰可以检查是否是函数式接口</li>
</ul>
<p>下面附上一个实战例子<br>首先建一个函数式接口，获取一个值参数是Interge类型<br>@FunctionalInterface<br>public interface MyFun {</p>
<pre><code>public Integer getValue(Integer num);
</code></pre><p>}<br>其次在类里面声明操作方法，函数式接口作为参数，不做具体实现，因为会写死<br>    public Integer operation(Integer num,MyFun mf){<br>        return mf.getValue(num);<br>    }<br>接着使用Lambda表达式来具体实现，比如实现加法以及平方<br>//需求，对一个数进行运算<br>    @Test<br>    public void test6(){<br>        Integer num =  operation(100, (x) -&gt; x * x);<br>        System.out.println(num);</p>
<pre><code>    System.out.println(operation(200, y -&gt; y + 200));
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/JVM之自动内存管理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/JVM之自动内存管理机制/" itemprop="url">JVM之自动内存管理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T15:38:07+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java内存区域与内存溢出异常<br>java虚拟机的基本结构<br><img src="/2018/03/24/JVM之自动内存管理机制/515180708318.png" alt="enter description here" title="515180708318.png"><br>类加载子系统<br>    类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。<br>程序计数器<br>    程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。<br>    如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。<br>    此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError情况的区域。<br>java虚拟机栈<br>    线程私有，它的生命周期与线程相同。线程执行的基本行为是函数调用，每次函数调用的数据都是通过java栈传递的。当前正在执行的函数锁对应的帧就是当前的帧（位于栈顶），它保存着当前函数的局部变量、中间运算结果等数据。当函数返回时，栈帧从栈中被弹出。Java方法有两种返回函数的方式，一种是正常的函数返回，使用return命令；另一种是逃出异常，不管使用哪种方式，都会导致栈帧被弹出。在一个栈帧中，至少要包含局部变量表、操作数栈和帧数据区几个部分。<br>    <img src="/2018/03/24/JVM之自动内存管理机制/2.png" alt="enter description here" title="2.png"><br>    局部变量表用于存放方法参数和方法内部定义的局部变量。局部变量表中的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。在java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。<br>在Class文件的局部变量表中，显示了每个局部变量的作用域范围、所在槽位的索引，变量名和数据类型。<br>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static方法），那么局部变量表中第0位索引默认是用于传递方法所述对象实例的应用，即this关键字。<br>  局部变量表中的Slot是可以重用的，当PC计数器的值超过了某个变量的作用域，则改变量的Slot可以被其他变量覆盖。<br>  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都是不会被回收的。<br>  操作数栈，操作数栈的最大深度也是在编译时写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的java数据类型。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容。<br>  栈数据区，Java栈帧还需要一些数据来支持常量池解析、正常方法返回和异常处理等。<br>在帧数据区中保存着访问常量池的指针，方便程序访问常量池。每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用持有这个引用是为了支持方法调用过程中的动态连接。虚拟机运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。如果符号引用是在类加载阶段或者第一次使用的时候转化为直接引用，那么这种转换成为静态解析，如果是在运行期间转换为直接引用，那么这种转换就成为动态连接。<br>  方法的返回分为两种情况，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者，一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置，如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址，如果是因为异常退出的，则是需要通过异常处理表来确定。方法的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，同时还会把PC计数器的值调整为方法调用入口的下一条指令。<br>  异常，在Java 虚拟机规范中，对虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。<br>  栈上分配，其基本思想是对于那些线程私有的对象（指不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾收集器的接入，从而提高系统的性能。栈上分配依赖于逃逸分析（-XX:+DoEscapeAnalysis）和标量替换（-XX:+EliminateAllocations，默认打开，允许将对象打散分配在栈上）的实现。<br>本地方法栈<br>    本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>    与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。<br>java堆<br>    堆是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。<br>    堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。<br>    堆的大小可以通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap大小，通常-Xms与-Xmx的值设成一样。<br>    如果从内存回收的角度看，由于现代收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；<br>    新生代：程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。<br>    老年代：用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：1、大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。2、大的数组对象，且数组中无引用外部对象。<br>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。<br>    如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。<br>    <img src="/2018/03/24/JVM之自动内存管理机制/3.png" alt="enter description here" title="3.png"><br>    方法区<br>    在JDK 1.6、JDK 1.7中，方法区可以理解为永久区（Perm，可以使用参数-XX:PermSize和-XX:MaxPermSize指定）。在JDK 1.8中，永久区已经被移除，取而代之的是元数据区（-XX:MaxMetaspaceSize指定）。在一个jvm实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在加载类时从.class文件中提取出来的。类(静态)变量也存储在方法区中。<br>    简单说方法区用来存储类型的元数据信息，一个.class文件是类被java虚拟机使用之前的表现形式，一旦这个类要被使用，java虚拟机就会对其进行装载、连接（验证、准备、解析）和初始化。而装载后的结果就是由.class文件转变为方法区中的一段特定的数据结构。这个数据结构会存储如下信息：<br>    类型信息 类型的全限定名，类型的直接超类的全限定名，类型是类类型还是接口类型，类型的访问修饰符，任何直接超接口的全限定名的有序列表<br>    字段信息 字段名，字段类型，字段的修饰符<br>    方法信息 方法名，方法返回类型，方法参数的数量和类型（按照顺序），方法的修饰符<br>    其他信息 除了常量以外的所有类（静态）变量，一个指向ClassLoader的指针，一个指向Class对象的指针，常量池（常量数据以及对其他类型的符号引用）<br>    JVM为每个已加载的类型都维护一个常量池。常量池就是这个类型用到的常量的一个有序集合，包括实际的常量(string,integer,和floating point常量)和对类型，域和方法的符号引用。池中的数据项像数组项一样，是通过索引访问的。每个类的这些元数据，无论是在构建这个类的实例还是调用这个类某个对象的方法，都会访问方法区的这些元数据。<br>构建一个对象时，JVM会在堆中给对象分配空间，这些空间用来存储当前对象实例属性以及其父类的实例属性（而这些属性信息都是从方法区获得），注意，这里并不是仅仅为当前对象的实例属性分配空间，还需要给父类的实例属性分配，即实例化父类的某个子类时，JVM也会同时构建父类的一个对象。从另外一个角度也可以印证这个问题：调用当前类的构造方法时，首先会调用其父类的构造方法直到Object，而构造方法的调用意味着实例的创建，所以子类实例化时，父类肯定也会被实例化。<br>类变量被类的所有实例共享，即使没有类实例时你也可以访问它。这些变量只与类相关，所以在方法区中，它们成为类数据在逻辑上的一部分。在JVM使用一个类之前，它必须在方法区中为每个non-final类变量分配空间。<br>    方法区主要有以下几个特点：<br>    1、方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待。<br>    2、方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。<br>    3、方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集。<br>    可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>    对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（PermanentGeneration），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。<br>    相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。<br>    当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br>直接内存<br>    直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常。<br>在JDK 1.4中新加入的NIO类，引入了一种基于通道和缓冲区的IO方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中来回复制数据。<br>    Java的NIO库允许java程序使用直接内存。直接内存是在java堆外，直接向系统申请的内存区间。通常，访问直接内存的速度会优于java堆，但是分配内存的效率低于后者。<br>    直接内存适合申请次数较少、访问较频繁的场合。如何内存空间本身需要频繁申请，则并不适合使用直接内存。<br>    总结<br><img src="/2018/03/24/JVM之自动内存管理机制/4.png" alt="enter description here" title="4.png"><br>HotSpot虚拟机对象<br>对象的创建<br>    虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<br>    在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。Java堆是否规整是由采用的垃圾收集器是否带有压缩整理功能决定。即使是指针的移动类分配内存，也需要同步，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲。<br>   内存分配过程<br>    1、JVM 会试图为相关Java对象在Eden Space中初始化一块内存区域。<br>    2、当Eden空间足够时，内存申请结束；否则到下一步。<br>    3、JVM 试图释放Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）。释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区。<br>    4、Survivor区被用来作为Eden及Old的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区。<br>    5、当Old区空间不够时，JVM 会在Old区进行完全的垃圾收集（0级）。<br>    6、完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现“outofmemory”错误。<br>    内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。保证对象的实例字段在java代码中可以不赋初始值就直接使用。<br>接下来，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<br>最后，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化。<br>    内存分配策略</init></p>
<pre><code>1. 优先在Eden分配
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次minor GC。Minor GC后存活的对象会被移到第一个Survivor区，并清除Eden区；当下一次Eden区又没有足够空间进行分配时，再次发起Minor GC，对Eden区和第一个Survivor区进行垃圾回收，并将存活的对象移到第二个Survivor区，同时清除Eden区和第一个Survivor区。
新生代GC (Minor GC)：指发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
老年代GC (Major GC / Full GC)：指发生在老年代的GC，出现了Major GC， 经常会伴随至少一次的Minor GC（但也非绝对的，在Parallel Scavenge收集器的手机策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般比Minor GC慢10倍以上。
2. 大对象直接进入老年代
所谓的大对象是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长大的字符串及其数组。
3. 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄计数器。如果在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋升到老年代中。
4. 动态对象年龄判断
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或者等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
5. 空间分配担保
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这是也要改为进行一次Full GC。
</code></pre><p>对象的内存布局<br>    HotSpot虚拟机中，对象的内存布局可以分为3块区域：对象头，实例数据和对齐填充。<br>    对象头包括两部分：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>    实例数据是对象真正存储的有效信息，也就是程序中所定义的各种类型的字段内容。<br>    对齐填充是由于HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍。如果对象实例数据部分没有对齐的，就需要通过对齐填充来补全。<br>对象的访问定位<br>    对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：<br>    Object obj = new Object();<br>    假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的局部变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。<br>    由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。<br>    如果使用句柄访问方式，Java 堆中将会划分出一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br>    如果是指针访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<br>OOM异常<br>java堆溢出<br>    设置java堆大小为比较小的值（-Xms和-Xmx），不断创建对象，保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会产生内存溢出异常。要解决这个区域的异常，一般通过dump来分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露还是内存溢出。<br>    如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们。<br>如果不存在泄露，就是内存中的对象却是还必须存活着，那就应该检查虚拟机的堆参数，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。<br>虚拟机栈和本地方法栈溢出<br>    对于HotSpot来说，栈容量只由-Xss参数设定。如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br>    设置参数-Xss比较小，通过递归调用可以产生StackOverflowError异常。在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOutOfMemoryError异常。<br>    通过不断地建立线程的方式倒是可以产生内存溢出异常。如果为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。因为系统分配给每个进程的内存是有限制的，而虚拟机提供了参数来控制java堆和方法区的这两部分内存的最大值，剩余内存为进程最大内存-Xmx（最大堆容量）-MaxPermSize（最大方法区容量），程序计数器消耗内存可以忽略。<br>    一般来说StackOverflowError异常不太会发生（默认的栈深度在大多数情况下够用），即使发生，也可以通过发生时的错误堆栈查找问题所在。<br>方法区和运行时常量池溢出<br>    JDK 1.6及之前的版本中，常量池分配在永久代（在方法区内）内，我们可以通过设置-XX:PermSize和-XX:MaxPermSize限制方法去大小，从而间接限制其中常量池的容量。再通过String.valueof(i++).intern()方法就可以产生OOM异常。而使用JDK 1.7运行同样代码就不会得到相同结果。因为从1.7开始逐步“去永久代”。<br>    JDK 1.6中intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。而JDK1.7中intern()方法不会再复制实例，只是在常量池中记录首次出现的实例的引用。<br>    // JDK 1.6输出false，而JDK 1.7输出true；<br>    String str1 = new StringBuilder(“abc”).append(“def”).toString();<br>    System.out.println(str1.intern() == str1);<br>    方法区，存放的是Class相关信息，如类名，访问修饰符、常量池、字段描述、方法描述等。对于方法区的测试，基本思路是运行时产生大量的类去填满方法区，直到溢出。<br>本机直接内存溢出<br>    DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，默认与java堆最大值（-Xmx）一样。可以通过反射获取Unsafe实例进行内存分配来抛出OOM异常。由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常。如果发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那可以考虑检查一下是不是直接内存溢出。<br>内存溢出和内存泄漏<br>    内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer，但给它存了long才能存下的数，那就是内存溢出。<br>    内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>memory leak会最终会导致out ofmemory。<br>    Java 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heapspace”。<br>    要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。<br>    如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。<br>    如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>垃圾收集算法：1.标记-清除算法  2.复制算法  3.标记-整理算法  4.分代收集算法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/java设计模式之工厂模式-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/java设计模式之工厂模式-1/" itemprop="url">java设计模式之工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T15:26:43+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">java设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简单工厂模式(Simple Factory Pattern)<br>从简单的工厂模式开始说起的话，我们要知道工厂模式的目的是什么？工厂模式的目的在于程序的可扩展性。而对于简单工厂模式来说，它是为了让程序有一个更好地封装，降低程序模块之间的耦合程度。对于简单的工厂模式，其实也可以将其理解成为一个创建对象的工具类。工具类的形式，可以仿造如下代码编写：<br>public class SimpleFactory {  </p>
<pre><code>public Object create(Class&lt;?&gt; clazz) {  
    if (clazz.getName().equals(Plane.class.getName())) {  
        return createPlane();  
    } else if (clazz.getName().equals(Broom.class.getName())) {  
        return createBroom();  
    }  

    return null;  
}  

private Broom createBroom() {  
    return new Broom();  
}  

private Plane createPlane() {  
    return new Plane();  
}  
</code></pre><p>}<br>测试代码如下：<br>public class FactoryTest {  </p>
<pre><code>public static void main(String[] args) {  
    // 简单工厂模式测试  
    SimpleFactory simpleFactory = new SimpleFactory();  
    Broom broom = (Broom) simpleFactory.create(Broom.class);  
    broom.run();  
}  
</code></pre><p>}<br>正如之前所说的，简单的工厂模式，就是去创建一个创建对象的工具类。在这个工具类里面，我们就可以进行一些其他操作，比如对象的初始化。这样就避免了把对象初始化的大量代码(如果有大量代码的话)放在构造函数里了。</p>
<p>工厂方法模式(Factory Method Pattern)<br>在简单的工厂模式里，我们创建了一个类似工具的类来创建相应的具体类对象。正因为其太过简单，有一点不成规范。所以，这里要对其做一些适当地封装。<br>我们来看一下工厂方法模式的定义吧。工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化哪一个。工厂方法让类把实例化推迟到了子类。（定义摘自《Head First设计模式》）<br><img src="/2018/03/24/java设计模式之工厂模式-1/%E5%B7%A5%E5%8E%821.png" alt="enter description here" title="工厂1.png"><br>抽象工厂：<br>我们的抽象工厂可以是类似这样的：<br>public abstract class VehicleFactory {<br>    public abstract Moveable create();<br>}<br>具体工厂：<br>代码就是这样简单而美好。而它有一个具体的实现工厂类：<br>public class BroomFactory extends VehicleFactory {  </p>
<pre><code>@Override  
public Moveable create() {  
    return new Broom();  
}  
</code></pre><p>}<br>这个具体的实现工厂告诉我们，这里可以通过 create() 方法来创建一个 Broom 对象。我们可以这样来理解他们的关系：有一个大的工厂它就是VehicleFactory，VehicleFactory工厂里又有很多生产车间，其中有一个就是BroomFactory。我们的具体产品都是通过这些生产车间来负责生产的。<br>抽象产品接口：<br>说到了产品，我们可以先试想一下这些具体的产品都会有什么样的性质。我们可以这样来定义它们：<br>public interface Moveable {<br>    public void run();<br>}<br>具体产品：<br>嗯，这是一些可以run(移动)的产品。就 BroomFactory 生产车间而言，它负责生产 Broom。这个 Broom 是具有 Moveable 的属性。那么它的实现可以这样来写：<br>public class Broom implements Moveable {  </p>
<pre><code>@Override  
public void run() {  
    System.out.println(&quot;我是Broom.我在飞...&quot;);  
}  
</code></pre><p>}<br>功能测试：<br>我们有工厂，并且知道了工厂要生产的产品了。那么我们就来生产一个 Broom 来试试吧：<br>VehicleFactory factory = new BroomFactory();<br>Moveable moveable = factory.create();<br>moveable.run();<br>这样我就生产了一个 Broom 了。是不是 so easy？</p>
<p>抽象工厂模式(Abstract Factory Pattern)<br>从上面的工厂方法中的结构图中，我们可以看到其中的具体工厂A和B是两个完全独立的。两者除了都是抽象工厂的子类，没有任何其他的交集。但是，如果我们有这样一个需求：具体工厂A和B需要生产一些同类型的不同产品。那么我们就可以试试抽象工厂模式。我们来看看抽象工厂模式是怎么定义的：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。同样在下面的结构图中，我们可以更好地解释这一定义。我们的抽象工厂中包含一系列的去构造一个抽象产品的方法，而具体产品的实现则是放在了具体工厂（图中的A和B）中进行。<br><img src="/2018/03/24/java设计模式之工厂模式-1/%E5%B7%A5%E5%8E%822.png" alt="enter description here" title="工厂2.png"><br>现在我们看看代码中是如何实现的。<br>抽象工厂：<br>public abstract class AbstractFactory {  </p>
<pre><code>public abstract Flyable createFlyable();  

public abstract Moveable createMoveable();  

public abstract Writeable createWriteable();  
</code></pre><p>}<br>具体工厂：<br>从抽象工厂的代码中也可以看出，抽象工厂只是去“生产”一些抽象的东西。有点类似于底层机制的感觉。现在我们来看看具体工厂的实现。<br>public class Factory1 extends AbstractFactory {  </p>
<pre><code>@Override  
public Flyable createFlyable() {  
    return new Aircraft();  
}  

@Override  
public Moveable createMoveable() {  
    return new Car();  
}  

@Override  
public Writeable createWriteable() {  
    return new Pen();  
}  
</code></pre><p>}<br>抽象产品接口：<br>在具体工厂里，我们就可以生产一些具体的产品了。就是这里的Aircraft、Car、Pen。抽象的产品接口如下。<br>public interface Flyable {  </p>
<pre><code>public void fly(int height);  
</code></pre><p>}<br>具体产品：<br>具体的产品则是要去实现这个接口，并实现其中的方法，如下：<br>public class Aircraft implements Flyable {  </p>
<pre><code>@Override  
public void fly(int height) {  
    System.out.println(&quot;我是一架客运机，我目前的飞行高度为：&quot; + height + &quot;千米。&quot;);  
}  
</code></pre><p>}<br>功能测试：<br>有了这些东西，那么我们就来好好生产一些产品吧。<br>public class FactoryTest {  </p>
<pre><code>public static void main(String[] args) {  
    AbstractFactory factory = new Factory1();  
    Flyable flyable = factory.createFlyable();  
    flyable.fly(1589);  

    Moveable moveable = factory.createMoveable();  
    moveable.run(87.6);  

    Writeable writeable = factory.createWriteable();  
    writeable.write(&quot;Hello World.&quot;);  
}  
</code></pre><p>}<br>现在让我们来看一下，结果是否跟我们想的一样吧。<br><img src="/2018/03/24/java设计模式之工厂模式-1/%E5%B7%A5%E5%8E%823.png" alt="enter description here" title="工厂3.png"></p>
<p>总结<br>以上就是工厂模式的基本实现和详细说明。包括了简单工厂模式、工厂方法模式、抽象工厂模式。我们可以基于需求来选择合适的工厂模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/java设计模式之代理模式-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/java设计模式之代理模式-1/" itemprop="url">java设计模式之代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T15:16:20+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">java设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java的三种代理模式<br>1.代理模式<br>代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.<br>这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法</p>
<p>举个例子来说明代理的作用:假设我们想邀请一位明星,那么并不是直接连接明星,而是联系明星的经纪人,来达到同样的目的.明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人)来解决.这就是代理思想在现实中的一个例子</p>
<p>用图表示如下:<br><img src="/2018/03/24/java设计模式之代理模式-1/1aa60bd74ae3537df3c2dec49fc93a7.png" alt="enter description here" title="1aa60bd74ae3537df3c2dec49fc93a7.png"></p>
<p>代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象</p>
<p>1.1.静态代理<br>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p>
<p>下面举个案例来解释:<br>模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.<br>需要注意的是,代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</p>
<p>代码示例:<br>接口:IUserDao.java</p>
<p>/**</p>
<ul>
<li><p>接口<br>*/<br>public interface IUserDao {</p>
<p> void save();<br>}<br>目标对象:UserDao.java</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>接口实现</li>
<li>目标对象<br>*/<br>public class UserDao implements IUserDao {<br> public void save() {<pre><code>System.out.println(&quot;----已经保存数据!----&quot;);
</code></pre> }<br>}<br>代理对象:UserDaoProxy.java</li>
</ul>
<p>/**</p>
<ul>
<li><p>代理对象,静态代理<br>*/<br>public class UserDaoProxy implements IUserDao{<br> //接收保存目标对象<br> private IUserDao target;<br> public UserDaoProxy(IUserDao target){</p>
<pre><code>this.target=target;
</code></pre><p> }</p>
<p> public void save() {</p>
<pre><code>System.out.println(&quot;开始事务...&quot;);
target.save();//执行目标对象的方法
System.out.println(&quot;提交事务...&quot;);
</code></pre><p> }<br>}<br>测试类:App.java</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>测试类<br>*/<br>public class App {<br> public static void main(String[] args) {</p>
<pre><code>//目标对象
UserDao target = new UserDao();

//代理对象,把目标对象传给代理对象,建立代理关系
UserDaoProxy proxy = new UserDaoProxy(target);

proxy.save();//执行的是代理的方法
</code></pre><p> }<br>}<br>静态代理总结:<br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>2.缺点:</p>
</li>
</ul>
<p>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.<br>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</p>
<p>1.2.动态代理<br>动态代理有以下特点:<br>1.代理对象,不需要实现接口<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>3.动态代理也叫做:JDK代理,接口代理</p>
<p>JDK中生成代理对象的API<br>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:</p>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )<br>注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:</p>
<p>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入<br>代码示例:<br>接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法</p>
<p>代理工厂类:ProxyFactory.java</p>
<p>/**</p>
<ul>
<li>创建动态代理对象</li>
<li><p>动态代理不需要实现接口,但是需要指定接口类型<br>*/<br>public class ProxyFactory{</p>
<p> //维护一个目标对象<br> private Object target;<br> public ProxyFactory(Object target){</p>
<pre><code>this.target=target;
</code></pre><p> }</p>
<p>//给目标对象生成代理对象<br> public Object getProxyInstance(){</p>
<pre><code>return Proxy.newProxyInstance(
        target.getClass().getClassLoader(),
        target.getClass().getInterfaces(),
        new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(&quot;开始事务2&quot;);
                //执行目标对象方法
                Object returnValue = method.invoke(target, args);
                System.out.println(&quot;提交事务2&quot;);
                return returnValue;
            }
        }
);
</code></pre><p> }</p>
</li>
</ul>
<p>}<br>测试类:App.java</p>
<p>/**</p>
<ul>
<li><p>测试类<br>*/<br>public class App {<br> public static void main(String[] args) {</p>
<pre><code>// 目标对象
IUserDao target = new UserDao();
// 【原始的类型 class cn.itcast.b_dynamic.UserDao】
System.out.println(target.getClass());

// 给目标对象，创建代理对象
IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
// class $Proxy0   内存中动态生成的代理对象
System.out.println(proxy.getClass());

// 执行方法   【代理对象】
proxy.save();
</code></pre><p> }<br>}<br>总结:<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理</p>
</li>
</ul>
<p>1.3.Cglib代理<br>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.<br>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)<br>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.<br>Cglib子类代理实现方法:<br>1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可.<br>2.引入功能包后,就可以在内存中动态构建子类<br>3.代理的类不能为final,否则报错<br>4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</p>
<p>代码示例:<br>目标对象类:UserDao.java</p>
<p>/**</p>
<ul>
<li><p>目标对象,没有实现任何接口<br>*/<br>public class UserDao {</p>
<p> public void save() {</p>
<pre><code>System.out.println(&quot;----已经保存数据!----&quot;);
</code></pre><p> }<br>}<br>Cglib代理工厂:ProxyFactory.java</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>Cglib子类代理工厂</li>
<li><p>对UserDao在内存中动态构建一个子类对象<br>*/<br>public class ProxyFactory implements MethodInterceptor{<br> //维护目标对象<br> private Object target;</p>
<p> public ProxyFactory(Object target) {</p>
<pre><code>this.target = target;
</code></pre><p> }</p>
<p> //给目标对象创建一个代理对象<br> public Object getProxyInstance(){</p>
<pre><code>//1.工具类
Enhancer en = new Enhancer();
//2.设置父类
en.setSuperclass(target.getClass());
//3.设置回调函数
en.setCallback(this);
//4.创建子类(代理对象)
return en.create();
</code></pre><p> }</p>
<p> @Override<br> public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {</p>
<pre><code>System.out.println(&quot;开始事务...&quot;);

//执行目标对象的方法
Object returnValue = method.invoke(target, args);

System.out.println(&quot;提交事务...&quot;);

return returnValue;
</code></pre><p> }<br>}<br>测试类:</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>测试类<br>*/<br>public class App {</p>
<p> @Test<br> public void test(){</p>
<pre><code>//目标对象
UserDao target = new UserDao();

//代理对象
UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();

//执行代理对象的方法
proxy.save();
</code></pre><p> }<br>}<br>在Spring的AOP编程中:<br>如果加入容器的目标对象有实现接口,用JDK代理<br>如果目标对象没有实现接口,用Cglib代理</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/java设计模式之单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zjz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分享至上">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/java设计模式之单例模式/" itemprop="url">java设计模式之单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T21:45:41+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">java设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.单例模式</p>
<ul>
<li>单例模式Singleton</li>
<li>应用场合：有些对象只需要一个就足够了，如古代的皇帝、老婆</li>
<li>作用：保证整个应用程序中某个实例有且只有一个</li>
<li><p>类型：饿汉模式、懒汉模式<br>饿汉模式代码举例<br>public class Singleton {<br>//1.将构造方法私有化，不允许外部直接创建对象<br>private Singleton(){</p>
<p>}<br>//2.创建类的唯一实例,使用private static<br>//static静态成员属于类所有，在类加载的时候就会去执行，当Singleton这个类被加载的时候，就会去创建这个类的唯一的实例，不管用户有没有去调用这个实例，只要类加载了，唯一实例就创建了，所以形象的称为饿汉模式<br>private static Singleton instance = new Singleton();</p>
<p>//3.提供一个用于获取实例的方法,使用public static修饰<br>public static Singleton getInstance(){</p>
<pre><code>return instance;
</code></pre><p>}<br>}<br>测试上面的小例子，结果输出为s1和s2是同一个实例，保证了对象只需要一个就够了<br>public static void main(String[] args) {</p>
<pre><code>Singleton s1 = Singleton.getInstance();  //这样就获取到了一个实例
Singleton s2 = Singleton.getInstance();
if(s1 == s2){
    System.out.println(&quot;s1和s2是同一个实例&quot;);  //说明无论获取多少次，都是指向同一个对象，保证了单例
}else{
    System.out.println(&quot;s1和s2不是同一个实例&quot;);
}
</code></pre><p>}<br>饿汉类型的单例模式总结：第一步：修改默认的构造方法；第二步：创建唯一的一个实例，并将其设置为static类型的 private static Singleton singleton = new Singleton()；第三步：定义一个public static Singleton getInstance()方法；——此即单例模式模式创建的饿汉模式（不管用户是否需要，只要类加载，就会去创建该单例模式的对象，即假设总是处于饥饿状态！！！）</p>
</li>
</ul>
<p>懒汉模式举例：<br>/*</p>
<ul>
<li><p>懒汉模式<br>*/<br>public class Singleton2 {<br>//1.将构造方法私有化，不允许外边直接创建对象<br> private Singleton2(){</p>
<p> }<br>//声明类的实例，使用private static修饰<br>private static Singleton2 instance;</p>
<p>//3.提供一个用于获取实例的方法，使用public static修饰<br>public static Singleton2 getInstance(){</p>
<pre><code>if(instance == null){
   instance = new Singleton2();
}
return instance;
</code></pre><p>}<br>}<br>对比饿汉模式，懒汉模式在类初始化的时候不会创建实例对象，仅仅只是声明，在需要的时候才去创建，所以称为懒汉模式创建对象比较后是同一个实例</p>
<pre><code>Singleton2 s3 = Singleton2.getInstance();
Singleton2 s4 = Singleton2.getInstance();
if(s3 == s4){
    System.out.println(&quot;s3和s4是同一个实例&quot;);  //说明无论获取多少次，都是指向同一个对象，保证了单例
}else{
    System.out.println(&quot;s3和s4不是同一个实例&quot;);
}
</code></pre></li>
</ul>
<p>饿汉与懒汉的区别<br>饿汉模式的特点是加载类时比较慢，但是运行时获取对象的速度比较快，线程安全<br>懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全</p>
<p>懒汉式为什么线程不安全？<br>假设开始线程0进入，判断instance为空，在将要创建实例时，cpu切换，线程1又进来了，同样instance为空创建了实例，这是cpu切换回来到0线程，继续创建实可见，经过分析共创建了两个实例，还谈什么单例。<br>改进<br>public static Singleton2 getInstance(){<br>       if(instance == null){<br>           //改进后线程安全<br>          synchronized (Singleton2.class) {<br>            if(instance == null){<br>                instance = new Singleton2();<br>            }<br>        }<br>       }<br>       return instance;<br>   }<br>可以保证线程安全同时又提高了效率。假设0线程进来，instance为空，进入同步代码块，cpu切换，线程1进来，instance为空，在同步代码块外，因为此时0正在里面ok，cup切换，执行创建实例，当1在进入代码块后，此时instace不为空，直接返回instance当在有线程进来instance不为空，不用执行同步代码块，效率提供了。<br>结论:一般开发都是饿汉式，因为不管怎么样，都是需要实例，那就不如先加载了（自己理解的），</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zjz</p>
              <p class="site-description motion-element" itemprop="description">分享之上</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zjz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
